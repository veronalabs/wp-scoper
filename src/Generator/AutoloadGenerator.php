<?php

declare(strict_types=1);

namespace VeronaLabs\WpScoper\Generator;

use Symfony\Component\Finder\Finder;

class AutoloadGenerator
{
    /**
     * Generate autoload.php and classmap for the target directory.
     *
     * @param string $targetDirectory
     * @param array<string> $filesAutoload Files that need require_once (from package autoload.files)
     */
    public function generate(string $targetDirectory, array $filesAutoload = []): void
    {
        $classmap = $this->buildClassmap($targetDirectory);
        $this->writeClassmap($targetDirectory, $classmap);
        $this->writeAutoloader($targetDirectory, $filesAutoload);
    }

    /**
     * Scan all PHP files and build class â†’ file mapping.
     *
     * @return array<string, string> class name => relative file path
     */
    public function buildClassmap(string $targetDirectory): array
    {
        $classmap = [];

        if (!is_dir($targetDirectory)) {
            return $classmap;
        }

        $finder = new Finder();
        $finder->files()->name('*.php')->in($targetDirectory);

        foreach ($finder as $file) {
            $relativePath = $file->getRelativePathname();
            $contents = $file->getContents();

            // Extract namespace
            $namespace = '';
            if (preg_match('/^\s*namespace\s+([A-Za-z0-9_\\\\]+)\s*;/m', $contents, $nsMatch)) {
                $namespace = $nsMatch[1];
            }

            // Extract class/interface/trait/enum declarations
            if (preg_match_all(
                '/^\s*(?:abstract\s+|final\s+)?(?:class|interface|trait|enum)\s+([A-Za-z_][A-Za-z0-9_]*)/m',
                $contents,
                $matches
            )) {
                foreach ($matches[1] as $className) {
                    $fqcn = $namespace ? $namespace . '\\' . $className : $className;
                    $classmap[$fqcn] = $relativePath;
                }
            }
        }

        ksort($classmap);
        return $classmap;
    }

    private function writeClassmap(string $targetDirectory, array $classmap): void
    {
        $lines = ["<?php\n", "// Generated by wp-scoper. Do not edit.\n", "return [\n"];

        foreach ($classmap as $class => $file) {
            $escapedClass = addcslashes($class, "'\\");
            $escapedFile = addcslashes($file, "'\\");
            $lines[] = "    '{$escapedClass}' => __DIR__ . '/{$escapedFile}',\n";
        }

        $lines[] = "];\n";

        file_put_contents(
            $targetDirectory . '/autoload-classmap.php',
            implode('', $lines)
        );
    }

    private function writeAutoloader(string $targetDirectory, array $filesAutoload): void
    {
        $filesRequires = '';
        foreach ($filesAutoload as $file) {
            $escapedFile = addcslashes($file, "'\\");
            $filesRequires .= "require_once __DIR__ . '/{$escapedFile}';\n";
        }

        $content = <<<'PHP'
<?php

// Generated by wp-scoper. Do not edit.

spl_autoload_register(function ($class) {
    static $classmap = null;

    if ($classmap === null) {
        $classmap = require __DIR__ . '/autoload-classmap.php';
    }

    if (isset($classmap[$class])) {
        require __DIR__ . '/' . $classmap[$class];
    }
});

PHP;

        if ($filesRequires !== '') {
            $content .= "\n// Files autoload\n" . $filesRequires;
        }

        file_put_contents($targetDirectory . '/autoload.php', $content);
    }
}
