<?php

declare(strict_types=1);

namespace VeronaLabs\WpScoper\Generator;

use Symfony\Component\Finder\Finder;

class AutoloadGenerator
{
    /**
     * Generate autoload.php and classmap for the target directory.
     *
     * @param string $targetDirectory
     * @param array<string> $filesAutoload Files that need require_once (from package autoload.files)
     * @param array<string, string|string[]> $hostPsr4 Host project PSR-4 mappings (namespace => dir)
     * @param string $projectRoot Absolute path to the host project root
     */
    public function generate(
        string $targetDirectory,
        array $filesAutoload = [],
        array $hostPsr4 = [],
        string $projectRoot = ''
    ): void {
        $classmap = $this->buildClassmap($targetDirectory);
        $this->writeClassmap($targetDirectory, $classmap);
        $this->writeAutoloader($targetDirectory, $filesAutoload, $hostPsr4, $projectRoot);
    }

    /**
     * Scan all PHP files and build class â†’ file mapping.
     *
     * @return array<string, string> class name => relative file path
     */
    public function buildClassmap(string $targetDirectory): array
    {
        $classmap = [];

        if (!is_dir($targetDirectory)) {
            return $classmap;
        }

        $finder = new Finder();
        $finder->files()->name('*.php')->in($targetDirectory);

        foreach ($finder as $file) {
            $relativePath = $file->getRelativePathname();
            $contents = $file->getContents();

            // Extract namespace
            $namespace = '';
            if (preg_match('/^\s*namespace\s+([A-Za-z0-9_\\\\]+)\s*;/m', $contents, $nsMatch)) {
                $namespace = $nsMatch[1];
            }

            // Extract class/interface/trait/enum declarations
            if (preg_match_all(
                '/^\s*(?:(?:abstract|final|readonly)\s+)*(?:class|interface|trait|enum)\s+([A-Za-z_][A-Za-z0-9_]*)/m',
                $contents,
                $matches
            )) {
                foreach ($matches[1] as $className) {
                    $fqcn = $namespace ? $namespace . '\\' . $className : $className;
                    $classmap[$fqcn] = $relativePath;
                }
            }
        }

        ksort($classmap);
        return $classmap;
    }

    private function writeClassmap(string $targetDirectory, array $classmap): void
    {
        $lines = ["<?php\n", "// Generated by wp-scoper. Do not edit.\n", "return [\n"];

        foreach ($classmap as $class => $file) {
            $escapedClass = addcslashes($class, "'\\");
            $escapedFile = addcslashes($file, "'\\");
            $lines[] = "    '{$escapedClass}' => '{$escapedFile}',\n";
        }

        $lines[] = "];\n";

        file_put_contents(
            $targetDirectory . '/autoload-classmap.php',
            implode('', $lines)
        );
    }

    private function writeAutoloader(
        string $targetDirectory,
        array $filesAutoload,
        array $hostPsr4,
        string $projectRoot
    ): void {
        $filesRequires = '';
        foreach ($filesAutoload as $file) {
            $escapedFile = addcslashes($file, "'\\");
            $filesRequires .= "require_once __DIR__ . '/{$escapedFile}';\n";
        }

        // Build PSR-4 map for host project
        $psr4Section = '';
        if (!empty($hostPsr4) && $projectRoot !== '') {
            // Calculate relative path from target directory to project root
            $relativeToRoot = $this->getRelativePath($targetDirectory, $projectRoot);

            $psr4Lines = [];
            foreach ($hostPsr4 as $namespace => $dirs) {
                $dirs = (array) $dirs;
                foreach ($dirs as $dir) {
                    $escapedNs = addcslashes($namespace, "'\\");
                    $escapedDir = addcslashes($relativeToRoot . '/' . rtrim($dir, '/'), "'\\");
                    $psr4Lines[] = "        '{$escapedNs}' => __DIR__ . '/{$escapedDir}',";
                }
            }

            if (!empty($psr4Lines)) {
                $psr4Map = implode("\n", $psr4Lines);
                $psr4Section = <<<PHP

// PSR-4 autoload (host project)
spl_autoload_register(function (\$class) {
    static \$psr4Map = [
{$psr4Map}
    ];

    foreach (\$psr4Map as \$prefix => \$baseDir) {
        \$len = strlen(\$prefix);
        if (strncmp(\$prefix, \$class, \$len) !== 0) {
            continue;
        }

        \$relativeClass = substr(\$class, \$len);
        \$file = \$baseDir . '/' . str_replace('\\\\', '/', \$relativeClass) . '.php';

        if (file_exists(\$file)) {
            require \$file;
            return;
        }
    }
});

PHP;
            }
        }

        $content = <<<'PHP'
<?php

// Generated by wp-scoper. Do not edit.

spl_autoload_register(function ($class) {
    static $classmap = null;

    if ($classmap === null) {
        $classmap = require __DIR__ . '/autoload-classmap.php';
    }

    if (isset($classmap[$class])) {
        require __DIR__ . '/' . $classmap[$class];
    }
});

PHP;

        $content .= $psr4Section;

        if ($filesRequires !== '') {
            $content .= "\n// Files autoload\n" . $filesRequires;
        }

        file_put_contents($targetDirectory . '/autoload.php', $content);
    }

    /**
     * Calculate relative path from one directory to another.
     */
    private function getRelativePath(string $from, string $to): string
    {
        $from = rtrim(str_replace('\\', '/', $from), '/');
        $to = rtrim(str_replace('\\', '/', $to), '/');

        $fromParts = explode('/', $from);
        $toParts = explode('/', $to);

        // Find common prefix
        $common = 0;
        $max = min(count($fromParts), count($toParts));
        for ($i = 0; $i < $max; $i++) {
            if ($fromParts[$i] !== $toParts[$i]) {
                break;
            }
            $common++;
        }

        // Go up from $from to common ancestor
        $ups = count($fromParts) - $common;
        $relative = str_repeat('/..', $ups);

        // Go down to $to from common ancestor
        $downs = array_slice($toParts, $common);
        if (!empty($downs)) {
            $relative .= '/' . implode('/', $downs);
        }

        return ltrim($relative, '/');
    }
}
